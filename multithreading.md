# [На главную](https://github.com/xXxCLOTIxXx/python_couch)


#### Многопоточность в Python реализуется с помощью различных механизмов, таких как потоки (threads), процессы (processes) и асинхронное программирование. Вот основные аспекты многопоточности в Python:
# 1. Потоки (Threads)

Потоки (threads) позволяют выполнять несколько задач одновременно в пределах одного процесса. В Python работа с потоками осуществляется с помощью модуля threading.

## Пример создания и запуска потока:

```python

import threading

def print_numbers():
    for i in range(5):
        print(i)

thread = threading.Thread(target=print_numbers)
thread.start()
thread.join()  # Ожидаем завершения потока
```
### Особенности:
 Python использует Global Interpreter Lock (GIL), который ограничивает выполнение байт-кода Python только одним потоком в любой момент времени. Из-за GIL потоки в Python не обеспечивают параллелизма в использовании нескольких ядер процессора, но они полезны для I/O-операций (например, работа с сетью, файлами).



# 2. Процессы (Processes)

Для более полноценного использования многопроцессорных систем Python предоставляет модуль multiprocessing, который позволяет создавать отдельные процессы с собственной памятью.

## Пример создания и запуска процесса:

```python

import multiprocessing

def print_numbers():
    for i in range(5):
        print(i)

process = multiprocessing.Process(target=print_numbers)
process.start()
process.join()  # Ожидаем завершения процесса
```
### Особенности:
В отличие от потоков, процессы не разделяют память, что предотвращает гонки данных, но требует использования межпроцессного взаимодействия (IPC) для обмена данными между процессами.
Отсутствие GIL в процессах позволяет выполнять код Python параллельно на нескольких ядрах.






## 3. Давай рассмотрим основные функции и аргументы для модулей threading и multiprocessing в Python.
### threading — Многопоточность

Модуль threading предоставляет интерфейс для работы с потоками. Вот основные классы, функции и методы:
Основные классы и функции:

    threading.Thread

        Создает и управляет потоком.

        Основные аргументы:
            target: Целевая функция, которую нужно выполнить в потоке.
            args: Кортеж аргументов, передаваемых в целевую функцию.
            kwargs: Словарь именованных аргументов для целевой функции.
            name: Имя потока (по умолчанию автоматически присваивается).
            daemon: Если True, поток работает как фоновый, и завершение основного потока приведет к завершению всех фоновых потоков.

        Основные методы:
            start(): Запускает поток.
            join(timeout=None): Ожидает завершения потока. Опционально можно указать тайм-аут.
            is_alive(): Проверяет, выполняется ли поток в данный момент.
            setName(name), getName(): Устанавливает или получает имя потока.
            setDaemon(daemon), getDaemon(): Устанавливает или получает статус фонового потока.

    threading.Lock
        Обеспечивает механизм блокировки для синхронизации доступа к общим ресурсам.
        Основные методы:
            acquire(blocking=True, timeout=-1): Блокирует выполнение потока до получения блокировки.
            release(): Освобождает блокировку.

    threading.RLock (Reentrant Lock)
        Повторяющаяся блокировка, которая позволяет одному и тому же потоку захватывать блокировку несколько раз.
        Основные методы: Такие же, как у Lock.

    threading.Event
        Обеспечивает механизм для управления потоками с помощью флагов.
        Основные методы:
            set(): Устанавливает флаг события.
            clear(): Сбрасывает флаг события.
            wait(timeout=None): Ожидает установки флага события.
            is_set(): Проверяет, установлен ли флаг события.

    threading.Condition
        Объединяет блокировку с дополнительным состоянием для более сложной синхронизации потоков.
        Основные методы:
            acquire(), release(): Аналогично Lock.
            wait(timeout=None): Ожидает уведомления от другого потока.
            notify(n=1): Уведомляет один или несколько потоков, ожидающих этого условия.
            notify_all(): Уведомляет все потоки.

    threading.Semaphore
        Обеспечивает счетчик для ограничения доступа к ресурсу определенным числом потоков.
        Основные методы:
            acquire(blocking=True, timeout=None): Захватывает семафор, уменьшая счетчик.
            release(): Освобождает семафор, увеличивая счетчик.

---
Пример использования:

```python

import threading

def worker(num):
    print(f'Worker {num} is running')

threads = []
for i in range(5):
    thread = threading.Thread(target=worker, args=(i,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()
```

### multiprocessing — Многопроцессность

Модуль multiprocessing предоставляет возможность создания и управления отдельными процессами, которые могут работать параллельно, независимо друг от друга.
Основные классы и функции:

    multiprocessing.Process

        Создает и управляет процессом.

        Основные аргументы:
            target: Целевая функция, которую нужно выполнить в процессе.
            args: Кортеж аргументов, передаваемых в целевую функцию.
            kwargs: Словарь именованных аргументов для целевой функции.
            name: Имя процесса.
            daemon: Если True, процесс работает как фоновый, и завершение основного процесса приведет к завершению всех фоновых процессов.

        Основные методы:
            start(): Запускает процесс.
            join(timeout=None): Ожидает завершения процесса.
            is_alive(): Проверяет, выполняется ли процесс.
            terminate(): Принудительно завершает процесс.
            name: Получает или устанавливает имя процесса.

    multiprocessing.Queue
        Очередь для обмена данными между процессами.
        Основные методы:
            put(item): Добавляет элемент в очередь.
            get(block=True, timeout=None): Извлекает элемент из очереди, ожидая при необходимости.
            empty(): Проверяет, пуста ли очередь.

    multiprocessing.Pipe
        Двусторонний канал связи между процессами.
        Основные методы:
            send(obj): Отправляет объект по каналу.
            recv(): Получает объект из канала.
            close(): Закрывает канал.

    multiprocessing.Lock
        Механизм блокировки для синхронизации доступа к ресурсам между процессами (аналогично threading.Lock).

    multiprocessing.Pool
        Обеспечивает пул процессов для параллельного выполнения задач.
        Основные методы:
            apply(func, args=()): Выполняет функцию в одном из процессов пула.
            map(func, iterable): Применяет функцию к каждому элементу итерируемого объекта, распределяя задачи по процессам.
            apply_async(func, args=()): Асинхронно выполняет функцию в процессе пула.
            close(): Закрывает пул, запрещая добавление новых задач.
            join(): Ожидает завершения всех задач в пуле.

---
Пример использования:

```python

import multiprocessing

def worker(num):
    print(f'Worker {num} is running')

processes = []
for i in range(5):
    process = multiprocessing.Process(target=worker, args=(i,))
    processes.append(process)
    process.start()

for process in processes:
    process.join()
```

---

# [Aсинхронное программирование](async.md)







