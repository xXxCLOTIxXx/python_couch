# [На главную](https://github.com/xXxCLOTIxXx/python_couch)


Функции в Python — это основные строительные блоки программы, которые позволяют структурировать и многократно использовать код. Они принимают входные данные, выполняют определённые действия и могут возвращать результат.
# 1. Объявление функции

Функции объявляются с использованием ключевого слова def, за которым следует имя функции, список параметров в скобках, и двоеточие. Тело функции должно быть отступом отступлено относительно строки с def.

```python

def имя_функции(параметры):
    # Тело функции
    инструкции
```
#### Пример:

```python

def greet(name):
    print(f"Привет, {name}!")
```
# 2. Вызов функции

Чтобы вызвать функцию, достаточно написать её имя, передав необходимые аргументы:

```python

greet("Алексей")  # Вывод: Привет, Алексей!
```
# 3. Параметры функции

Функции могут принимать параметры, которые передаются во время вызова функции. В Python есть несколько типов параметров:
### 1. Позиционные параметры

Аргументы передаются в функцию в том порядке, в котором они указаны.

```python

def add(a, b):
    return a + b

result = add(3, 5)  # Вывод: 8
```
### 2. Именованные параметры

Аргументы можно передавать по имени, что позволяет их указывать в любом порядке.

```python

def subtract(a, b):
    return a - b

result = subtract(b=5, a=10)  # Вывод: 5
```
### 3. Параметры по умолчанию

Можно задать значения параметров по умолчанию, которые будут использованы, если аргументы не переданы.

```python

def greet(name="гость"):
    print(f"Привет, {name}!")

greet()          # Вывод: Привет, гость!
greet("Анна")    # Вывод: Привет, Анна!
```
### 4. Неопределённое количество аргументов

Используя *args и **kwargs, можно передавать произвольное количество позиционных и именованных аргументов.

```python

# *args для произвольного числа позиционных аргументов
def add(*args):
    return sum(args)

print(add(1, 2, 3))  # Вывод: 6

# **kwargs для произвольного числа именованных аргументов
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Анна", age=25)  
# Вывод:
# name: Анна
# age: 25
```
# 4. Возвращение значений из функции

Функция может возвращать результат с помощью ключевого слова return. Если return не используется, функция вернёт None.

```python

def multiply(a, b):
    return a * b

result = multiply(4, 5)  # result будет равно 20
```
# 5. Область видимости переменных (Scope)

Переменные, объявленные внутри функции, являются локальными для этой функции и недоступны за её пределами.

```python

def example():
    x = 10  # Локальная переменная

example()
print(x)  # Ошибка, так как x не существует за пределами функции
```
Если нужно использовать переменную вне функции, её можно сделать глобальной с помощью ключевого слова global.

```python

x = 5

def modify():
    global x
    x = 10

modify()
print(x)  # Вывод: 10
```
# 6. Анонимные функции (lambda)

Анонимные функции создаются с использованием ключевого слова lambda. Эти функции ограничены одним выражением и не требуют имени.

```python

# Обычная функция
def add(a, b):
    return a + b

# Лямбда-функция
add_lambda = lambda a, b: a + b

print(add_lambda(3, 5))  # Вывод: 8
```
Лямбда-функции часто используются для создания коротких функций на месте, например, в качестве аргументов других функций.

```python

# Использование lambda в функции sort
items = [(1, 'яблоко'), (2, 'банан'), (3, 'вишня')]
items.sort(key=lambda item: item[1])
print(items)  
# Вывод: [(1, 'яблоко'), (2, 'банан'), (3, 'вишня')]
```
# 7. Рекурсия

Функция может вызывать сама себя — это называется рекурсией. Важно всегда иметь базовый случай, чтобы избежать бесконечной рекурсии.

```python

def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n - 1)

print(factorial(5))  # Вывод: 120
```
# 8. Декораторы

Декораторы — это функции, которые модифицируют поведение других функций. Они часто используются для добавления функциональности до или после выполнения основной функции.

```python

def decorator(func):
    def wrapper():
        print("Что-то делаем перед вызовом функции")
        func()
        print("Что-то делаем после вызова функции")
    return wrapper

@decorator
def say_hello():
    print("Привет!")

say_hello()
# Вывод:
# Что-то делаем перед вызовом функции
# Привет!
# Что-то делаем после вызова функции
```
# 9. Замыкания

Замыкания возникают, когда внутренняя функция запоминает переменные из области видимости внешней функции, даже если внешняя функция завершила выполнение.

```python

def outer_func(x):
    def inner_func(y):
        return x + y
    return inner_func

add_five = outer_func(5)
print(add_five(10))  # Вывод: 15
```
